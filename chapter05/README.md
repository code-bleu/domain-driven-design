# 05장. 소프트웨어에서 표현되는 모델

## Introduction

- 객체 간의 연관관계를 이해하고 묘사하기는 간단하지만 그것을 실제로 구현하는 것은 잠재적으로 다루기 힘든 문제일지도 모른다.
- 상세한 구현 결정이 MODEL-DRIVEN DESIGN 을 실현하는 데 얼마나 중요한가를 연관관계를 토대로 알게 될 것
- 모델을 표현하는 세 가지 패턴, 즉 ENTITY (엔티티), VALUE OBJECT (값 객체), SERVICE (서비스) 를 구분하는 데 초점을 맞춰 설명하겠다.
- **도메인 개념을 담은 객체를 정의하는 일은 겉으로는 매우 쉬워 보여도 거기에는 의미상의 미묘한 차이로 발생할 수 있는 중대한 문제가 잠재돼 있다.**
- 어떤 객체가 연속성 (continuity) 과 식별성 (identity, 각종 상태를 바탕으로 추적되거나 서로 다른 구현에 걸쳐 존재하는 것) 을 지닌 것을 의미하는가? 아니면 다른 뭔가의 상태를 기술하는 속성에 불과한가? 이것은 ENTITY 와 VALUE OBJECT 를 구분하는 가장 기본적인 방법
- SERVICE 는 클라이언트 요청에 대해 수행되는 뭔가를 의미
- 관계형 데이터베이스에 객체 모델을 저장하는 경우처럼 불가피하게 객체 모델의 무결함을 타협해야만 하는 상황도 있다.
- 마지막으로 MODULE (모듈) 에 관해 논의하면서 모든 설계 관련 의사결정은 도메인에 부여된 통찰력을 바탕으로 내려야 한다는 사실을 알게 될 것
- 기술적인 측정 수단으로 여겨지는 높은 응집도 (high cohesion) 와 낮은 결합도 (low coupling) 라는 개념은 도메인 개념에도 적용할 수 있다.
- MODEL-DRIVEN DESIGN 에서 MODULE 은 모델의 한 부분이므로 도메인의 개념을 반영해야 한다.

## 연관관계

- **모델의 모든 탐색 가능한 (traversable) 연관관계에 대해 그것과 동일한 특성을 지닌 메커니즘이 소프트웨어에도 있다.**
- 현실세계에는 수많은 다대다 (many-to-many) 연관관계가 있으며, 그 중 상당수는 애초부터 양방향 (bidirectional) 으로 나타남
- 그러나 이러한 일반적인 형태의 연관관계는 구현과 유지보수를 복잡하게 하며, 더욱이 해당 관계의 특성에 관해서는 거의 전해주는 바가 없다.
- 연관관계를 좀 더 쉽게 다루는 방법으로는 아래의 세 가지가 있다.
  - 탐색 방향을 부여
  - 한정자 (qualifier) 를 추가해서 사실상 다중성 (multiplicity) 을 줄인다.
  - 중요하지 않은 연관관계를 제거
- 가능한 한 관계를 제약하는 것이 중요
- 애플리케이션 요구사항에 두 방향을 모두 탐색해야 한다는 요청이 없을 경우 탐색 방향을 추가하면 상호의존성이 줄어들고 설계가 단순해짐
- 그리고 도메인을 이해하면 도메인 본연의 방향성이 드러날지도 모름
- **도메인을 더욱 깊이 이해하다 보면 굉장히 자주 “한정적인(quanlified)” 관계에 이름**
- 한정자는 다중성을 일대일로 줄이며, 중요한 규칙을 명시적으로 모델에 포함시킴
- 다대다 연관관계의 탐색 방향을 제약하면 해당 연관관계는 사실상 훨씬 더 구현하기 쉬운 일대다 연관관계로 줄어듦
- 도메인의 특성이 반영되게끔 연관관계를 일관되게 제약하면 연관관계의 의사전달력이 풍부해지고 구현이 단순해지며, 나머지 양방향 연관관계도 의미를 지니게 된다.
- **물론 당면한 문제에 필요한 것이 아니거나 중요한 의미를 담고 있는 모델 객체가 아니라면 궁극적인 단순화는 연관관계를 완전히 제거하는 것**

## ENTITY (엔티티, 참조객체라고도 함)

- **수많은 객체은 본질적으로 해당 객체의 속성이 아닌 연속성과 식별성이 이어지느냐를 기준으로 정의됨**
- 객체 모델링을 할 때 우리는 객체의 속성에 집중하곤 하는데, ENTITY 의 근본적인 개념은 객체의 생명주기 내내 이어지는 추상적인 연속성이며, 그러한 추상적인 연속성은 여러 형태를 거쳐 전달된다는 것
- 심지어 어떤 것은 다른 객체와 속성이 같아도 서로 구분해야 하는 경우도 있다.
- 잘못된 식별성은 데이터 손상으로 이어질 수 있다.
- **어떤 객체를 일차적으로 해당 객체의 식별성으로 정의할 경우 그 객체를 ENTITY 라 한다.**
- **ENTITY 에는 모델링과 설계상의 특수한 고려사항이 포함돼 있다.**
- **ENTITY 는 자신의 생명주기 동안 형태와 내용이 급격하게 바뀔 수도 있지만, 연속성은 유지해야 한다.**
- **또한 사실상 ENTITY 를 추적하려면 ENTITY 에 식별성이 정의돼 있어야 한다.**
- **ENTITY 의 클래스 정의와 책임, 속성, 연관관계는 ENTITY 에 포함된 특정 속성보다는 ENTITY 의 정체성에 초점을 맞춰야 한다.**
- 한편으로 모델 내의 모든 객체가 의미있는 식별성을 지닌 ENTITY 인 것은 아니다.
- 이러한 문제는 객체지향 언어에서 모든 객체에 “동일성(identity)” 연산이 내장돼 있다는 점 때문에 혼동되기도 한다.
  - 자바의 “==” 연산자
- 이 연산은 두 객체의 메모리 주소나 다른 어떤 메커니즘을 기준으로 두 객체 참조가 같은 객체를 가리키고 있는지 판단한다.
- 식별성은 ENTITY 의 미묘하고 의미 있는 속성이므로 언어에서 제공하는 자동화된 기능으로 대체할 수 없다.
- **한 객체가 속성보다는 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼아라.**
- **클래스 정의를 단순하게 하고 생명주기의 연속성과 식별성에 집중하라.**
- **객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단을 정의하라.**
- **객체의 속성으로 객체의 일치 여부를 판단하는 요구사항에 주의하라.**
- **각 객체에 대해 유일한 결과를 반환하는 연산을 정의하라.**
- **이러한 연산은 객체의 유일함을 보장받는 기호를 덧붙여서 정의할 수 있을지도 모른다.**
- **모델이 동일하다는 것이 무슨 의미인지 정의해야 한다.**
- 식별성은 원래 세상에 존재하는 것이 아니며, 필요에 의해 보충된 의미

### ENTITY 모델링

- 객체를 모델링할 때 속성에 관해 생각하는 것은 자연스러운 일이며, 특히 객체의 행위에 관해 생각해 보는 것은 아주 중요
- **ENTITY 의 가장 기본적인 책임은 객체의 행위가 명확하고 예측 가능해질 수 있게 연속성을 확립하는 것**
- ENTITY 는 별도로 분리돼 있을 때 자신의 책임을 가장 잘 수행한다.
- 개념에 필수적인 행위만 추가하고 그 행위에 필요한 속성만 추가한다.
- 그 밖의 객체는 행위와 속성을 검토해서 가장 중심이 되는 ENTITY 와 연관관계에 있는 다른 객체로 옮긴다.
- 식별성 문제를 제외하면 ENTITY 는 주로 자신이 소유한 객체의 연산을 조율해서 책임을 완수한다.

### 식별 연산의 설계

- **각 ENTITY 에는 다른 객체와 구분해줄 식별성(심지어 속성이 같은 다른 객체와도 구분할 수 있는)을 만들어내는 수단이 반드시 있어야 한다.**
- 식별에 사용되는 속성은 시스템의 상태(시스템이 분산돼 있거나 객체가 저장돼 있는 경우에도)와 관계없이 해당 시스템 내에서 유일해야 한다.
- 대부분의 객체 영속화 기술은 매번 데이터베이스에서 객체를 가져올 때마다 새로운 인스턴스를 생성하므로 초기 식별성은 잃어버리게 된다.
- 또한 매번 네트워크를 거쳐 객체가 전송될 때마다 목적지에서 새로운 인스턴스가 만들어지므로 또 다시 해당 객체의 식별성을 잃어버리게 된다.
- 두 객체가 개념적으로 동일한 ENTITY 를 나타내는지 어떻게 알 수 있는가?
- 식별성에 대한 정의는 모델로부터 나온다.
- 따라서 식별성을 정의하려면 도메인을 이해해야 한다.
- 때때로 어떤 데이터 속성이나 여러 속성의 조합이 시스템 내에서 유일함을 보장받거나 단순히 유일하도록 제약되기도 한다.
- 이 같은 접근법의 결과로 ENTITY 는 고유한 키를 제공받는다.
- 한 객체의 속성으로 구성되는 실질적인 고유키가 없다면 또 다른 일반적인 해법은 각 인스턴스에 해당 클래스 내에서 유일한 기호(숫자나 문자열과 같은)를 덧붙이는 것
- 일단 이러한 ID 기호가 생성되어 ENTITY 의 속성으로 저장되면 이 ID 는 불변성을 띠게 된다.
- 종종 시스템에서 이러한 ID 를 자동으로 만들어 내기도 한다.
- 이러한 ID 생성 알고리즘은 시스템 내에서 유일함을 보장해야 하는데, 병렬 처리 시스템이나 분산 시스템에서는 그렇게 하기가 쉽지 않을 수도 있으며, 유일한 ID 를 생성하는 문제는 이 책의 범위를 넘어서는 기술이 필요할지도 모른다.
- 중요한 건 그러한 식별성에 관한 문제는 모델의 구체적인 면면에 따라 달라진다는 사실을 아는 것
- 종종 식별 수단도 마찬가지로 도메인에 대한 철저한 연구가 필요
- 마지막으로 생성된 ID 가 사용자에게 중요한 경우가 있음
- ID 의 유일성이 컴퓨터 시스템의 범위를 넘어 적용돼야 할 때도 있음
- 애플리케이션에서 외부 ID 가 필요한 경우 시스템의 사용자는 유일한 ID 를 제공할 책임을 지게 되며, 해당 시스템에서는 발생한 예외 상황을 처리할 적절한 수단을 제공해야 한다.
- **그런데 이러한 모든 기술적 문제를 감안하더라도 “두 객체가 동일하다는 것이 무엇을 의미하는가?” 라는 근원적인 문제를 놓치기 쉽다.**
- ID 를 가진 각 객체를 표시하거나 두 인스턴스를 비교하는 연산을 작성하기는 쉽지만 이러한 ID 나 연산이 도메인에 의미 있는 구분법에 부합하지 않는다면 문제를 더욱 혼란스럽게 만들 뿐이다.
- 이는 식별성 할당 연산에 간혹 사람이 개입할 때가 있기 때문이다.

## VALUE OBJECT (값 객체)

- **개념적 식별성이 없는 객체도 많은데, 이러한 객체는 사물의 어떤 특징을 묘사한다.**
- ENTITY의 식별성을 관리하는 일은 매우 중요하지만 그 밖의 객체에 식별성을 추가한다면 시스템의 성능이 저하되고, 분석 작업이 별도로 필요하며, 모든 객체를 동일한 것으로 보이게 해서 모델이 혼란스러워질 수 있다.
- **소프트웨어 설계는 복잡성과의 끊임없는 전투다.**
- **그러므로 우리는 특별하게 다뤄야 할 부분과 그렇지 않은 부분을 구분해야 한다.**
- 사실 이 같은 객체는 자체적인 특징을 비롯해 모델에 중요한 의미를 지닌다.
- 이것들이 바로 사물을 서술하는 객체다.
- 개념적 식별성을 갖지 않으면서 도메인의 서술적 측면을 나타내는 객체를 VALUE OBJECT 라 한다.
- VALUE OBJECT 는 설계 요소를 표현할 목적으로 인스턴스화되는데, 우리는 이러한 설계 요소가 어느 것인지에 대해서는 관심이 없고, 오직 해당 요소가 무엇인지에 대해서만 관심이 있다.
- 어떤 VALUE OBJECT 는 다른 여러 객체를 조립한 것일 수도 있다.
- VALUE OBJECT 가 ENTITY 를 참조할 수도 있다.
- 간혹 VALUE OBJECT 는 여러 객체 간에 오가는 메시지의 매개변수로 전달되기도 한다.
- VALUE OBJECT 는 종종 한 연산에서 사용할 목적으로 만들어진 후 폐기되는 것처럼 일시적인 용도로 사용되기도 한다.
- 또한 ENTITY (그리고 다른 VALUE) 의 속성으로 사용되기도 한다.
- 한 사람은 식별성을 지닌 ENTITY 로 모델링할 수 있는 반면, 그 사람의 이름은 VALUE 인것처럼 말이다.
- **모델에 포함된 어떤 요소의 속성에만 관심이 있다면, 그것을 VALUE OBJECT 로 분류하라.**
- **VALUE OBJECT 에서 해당 VALUE OBJECT 가 전하는 속성의 의미를 표현하게 하고 관련된 기능을 부여하라.**
- **또한 VALUE OBJECT 는 불변적(immutable)으로 다뤄라.**
- **VALUE OBJECT 에는 아무런 식별성도 부여하지 말고 ENTITY 를 유지하는 데 필요한 설계상의 복잡성을 피하라.**
- VALUE OBJECT 를 구성하는 속성은 개념적 완전성 (conceptual whole) 을 형성해야 한다.

### VALUE OBJECT 의 설계

- **여러 VALUE OBJECT 의 인스턴스 가운데 어느 것을 사용하는지는 중요하지 않다.**
- **이런 식으로 제약조건이 줄어들면 설계 단순화나 성능 최적화를 꾀할 수 있다.**
- **하지만 여기에는 복사, 공유, 불변성에 관한 의사결정이 따른다.**
- 변경을 방지해서 객체를 안전하게 공유할 수 있으려면 해당 객체가 불변적이어야 한다.
- VALUE OBJECT 는 많아지는 경향이 있으므로 성능 최적화를 위한 별도의 대안을 마련하는 것이 중요할 수 있다.
- 복사와 공유 중 어느 것이 경제성 면에서 더 나은지는 구현환경에 따라 달라진다.
- 복사의 경우 객체의 개수가 굉장히 많아져 시스템이 무거워질 수도 있지만, 공유 또한 분산 시스템에서는 느려질 수 있다.
- **공유는 다음과 같은 경우 가장 도움이 되고 문제가 적게 일어나며, 이러한 경유로 공유를 제한한다.**
  - **공간을 절약하거나 데이터베이스 내의 객체 수를 줄이는 것이 중요한 경우**
  - **통신 부하가 낮은 경우 (이를테면, 중앙집중형 서버)**
  - **공유 객체의 불변성이 엄격하게 지켜지는 경우**
- 속성이나 객체의 불변성은 특정 언어나 환경에서만 선언할 수 있다.
- 그러나 언어에서 개념적 구분을 직접적으로 지원해 주지 않는다고 해서 그러한 구분 자체가 유용하지 않다는 의미는 아니다.
- 이것은 단지 구현에 암시적으로만 존재할 규칙을 유지하는 노력이 좀 더 필요하다는 의미일 뿐이다.
- 이러한 명명관례와 선택적 문서화를 비롯해 수많은 논의를 거쳐 개선할 수 있다.
- **VALUE OBJECT 가 불변적인 한 변경관리는 단순해진다.**
- **즉 완전히 교체하지 않는 한 아무것도 변경되지 않는다.**
- **불변 객체는 전기 콘센트의 예처럼 마음껏 공유할 수 있다.**
- **가비지 컬렉션이 믿을 만 하다면 삭제는 단순히 객체에 대한 모든 객체 참조를 폐기하는 문제에 불과하다.**
- **VALUE OBJECT 가 설계에서 불변적이라는 의미를 나타낼 경우 개발자들은 애플리케이션이 특정 객체의 인스턴스에 의존하지 않는다는 점을 토대로 순수하게 기술적인 근거에 따라 복사와 공유와 같은 문제에 관해 자유롭게 의사 결정을 내릴 수 있다.**
- 변경 가능성을 허용하는 경우
  - VALUE 가 자주 변경되는 경우
  - 객체 생성이나 삭제에 비용이 많이 드는 경우
  - 교체(변경이 아닌)로 인해 클러스터링이 제한되는 경우
  - VALUE 를 공유할 일이 그리 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 보류된 경우
  - VALUE 의 구현이 변경 가능하다면 그것을 공유해서는 안된다.
  - VALUE 의 공유 여부와는 관계없이 VALUE OBJECT 는 가급적 변하지 않게 설계한다.
- VALUE OBJECT 를 정의하고 그것이 불변적임을 나타나게 하는 것은 다음과 같은 일반 규칙, 즉 모델에서 불필요한 제약을 피하면 개발자가 순수하게 기술적인 성능 최적화를 마음껏 수행할 수 있다는 것을 따르는 셈
- 필수적인 제약조건을 명시적으로 정의하면 중요 행위가 변경되는 것으로부터 설계를 안전하게 유지하는 동시에 개발자들이 설계를 최적화할 수 있다.
- 하지만 그러한 설계 최적화는 종종 특정 프로젝트에서만 사용하는 기술에 매우 종속적일 때가 있다.

### VALUE OBJECT 를 포함한 연관관계 설계

- 모델에 포함된 연관관계 수가 더 적고 연관관계가 단순할수록 더 나은 모델이라 할 수 있다.
- **그런데 ENTITY 간의 양방향 연관관계는 유지하기는 어려울 수 있는 반면 VALUE OBJECT 간의 양방향 연관관계는 단순히 논리적으로 타당하지 않다.**
- 어떤 객체가 아무런 식별성 없이 자신을 가리키는 동일한 VALUE OBJECT \*\*\*\*을 역으로 가리키는 것은 아무런 의미가 없다.
- 기껏해야 한 객체가 자신을 가리키고 있는 것과 내용이 같은 어떤 객체를 가리키고 있다는 것에 불과하며, 어딘가에서는 해당 객체의 불변식을 이행해야 할 것
- VALUE OBJECT 간의 양방향 연관관계는 완전히 제거하도록 노력해야 한다.
- 모델에 그와 같은 연관관계가 필요해 보여도 그 객체를 VALUE OBJECT 로 선언하는 것은 한 번 더 고려해봐야 한다.
- 어쩌면 그 객체에 아직도 분명하게 파악하지 못한 식별성이 남아 있을지도 모른다.

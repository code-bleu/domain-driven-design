# 10. 유연한 설계

소프트웨어의 궁극적인 목적은 사용자를 만족시키는 것이다.

- 하지만 우선 그 소프트웨어는 개발자를 만족시켜야 한다.
- 도메인 객체를 애플리케이션 내부로 흡수하고 새로운 도메인 객체와 통합할 것이다.

복잡하게 동작하는 소프트웨어에 좋은 설계가 결여돼 있다면 요소들을 리팩터링하거나 결합하기가 어려워진다.

개발이 진행될수록 현재의 레거시 코드로 인한 중압감에 시달리지 않고 프로젝트 진행을 촉진하려면 변경을 수용하고 즐겁게 작업할 수 있는 설계가 필요하다. ⇒ 유연한 설계

- 유연한 설계는 심층 모델링을 보완한다.
- 암시적인 개념을 찾아내서 이를 명확하게 표현했다면 일단 심층 모델을 만들 원재료는 갖춘 셈이다.
- 무수히 많은 과도한 엔지니어링이 유연성이라는 명목으로 정당화되어 왔다.
- 대개 너무 과도한 추상 계층과 간접 계층이 존재하면 오히려 유연성에 방해가 된다.

일반적으로 초기에 작성된 설계는 유연하지 못하다.

소프트웨어를 유연하게 만드는 특별한 공식 같은 것은 없지만 개인적인 경험을 바탕으로 적절하게 적용할 경우 유연한 설계를 만들 수 있는 패턴 집합을 확인해본다.

### INTENTION-REVEALING INTERFACE (의도를 드러내는 인터페이스)

도메인 주도 설계를 적용할 때는 의미 있고 가치 있는 도메인 로직에 관해 생각하고자 한다.

명확하게 표현된 규칙 없이 암묵적인 규칙에 따라 실행되는 코드를 이해하려면 소프트웨어 프로시저를 구성하는 각 단계를 기억해야만 한다.

모델과의 연관관계가 분명하지 않을 경우 코드의 수행결과를 이해하거나 변경의 파급 효과를 예상하기가 어렵다.

개발자가 컴포넌트를 사용하기 위해 컴포넌트의 구현 세부사항을 고려해야 한다면 캡슐화의 가치는 사라진다.

원래의 개발자가 아닌 다른 개발자가 구현 내용을 토대로 객체나 연산의 목적을 추측해야 한다면 새로운 개발자는 우연에 맡긴 채 연산이나 클래스의 목적을 짐작할 가능성이 있다.

추측한 바가 원래의 취지에 어긋난다면 당장은 코드가 정상적으로 동작했다고 하더라도 설계의 개념적 기반은 무너지고 두 개발자는 서로 의도가 어긋난 상태로 일하게 된다.

수행 방법에 관해서는 언급하지 말고 결과와 목적만을 표현하도록 클래스와 연산의 이름을 부여하라. 이렇게 하면 클라이언트 개발자가 내부를 이해해야 할 필요성이 줄어든다.

전체 하위 도메인을 서로 다른 모듈로 분리하고 각 모듈을 intention-revealing interface를 사용해서 캡슐화할 수 있다.

### SIDE-EFFECT-FREE FUNCTION (부수효과가 없는 함수)

연산은 크게 명령과 질의로 나눌 수 있다.

질의는 변수 안에 저장된 데이터에 접근하거나, 저장된 데이터를 기반으로 계산을 수행해서 시스템으로부터 정보를 얻는 연산을 의미한다.

명령은 변수의 값을 변경하는 등의 작업을 통해 시스템의 상태를 변경하는 연산을 의미한다.

부수효과(SIDE EFFECT)

- 앞으로의 연산에 영향을 미치는 시스템 상태의 변경으로 의미를 한정한다.

다수의 규칙에 따라 상호작용하거나 여러 가지 계산을 조합하면 극도로 예측하기가 어려워진다.

연산을 호출하는 개발자가 결과를 예상하려면 연산 자체의 구현뿐 아니라 연산이 호출하는 다른 연산의 구현도 이해해야 한다.

부수효과를 일으키지 않으면서 결과를 반환하는 연산을 함수라고 한다.

함수는 여러번 호출해도 무방하며 매번 동일한 값을 반환한다.

대부분의 소프트웨어 시스템에서 명령을 사용하지 않기란 불가능하지만, 문제를 완화할 수는 있다.

1. 명령과 질의를 엄격하게 분리된 서로 다른 연산으로 유지하는 것
2. 기존의 객체를 전혀 변경하지 않고도 문제를 완화할 수 있는 대안적인 모델과 설계가 있다.

VALUE OBJECT는 불변 객체이며, 이것은 오직 VALUE OBJECT를 생성할 때만 호출되는 초기화 연산을 제외한 모든 연산이 함수이다.

가능한 한 많은 양의 프로그램 로직을 관찰 가능한 부수효과 없이 결과를 반환하는 함수 안에 작성하라. 명령을 도메인 정보를 반환하지 않는 아주 단순한 연산으로 엄격하게 분리하라.

한 걸음 더 나아가 책임에 적합한 어떤 개념이 나타난다면 복잡한 로직을 VALUE OBJECT로 옮겨서 부수효과를 통제하라.

### ASSERTION (단언)

ASSERTION을 사용하면 ENTITY의 부수효과가 명확해지고 다루기 쉬워진다.

복잡한 계산이 포함되지 않은 명령은 코드를 조사하는 것만으로도 연산의 결과를 쉽게 이해할 수 있다.

연산의 부수효과가 단지 구현에 의해서만 함축적으로 정의될 때 다수의 위임을 포함하는 설계는 인과 관계로 혼란스러워진다.

프로그램을 이해하려면 분기 경로를 따라 실행 경로를 추적하는 수밖에 없다.

이렇게 되면 캡슐화의 가치가 사라지고, 구체적인 실행 경로를 추적해야 한다는 필요성으로 추상화가 무의미해진다.

연산의 사후조건과 클래스 및 AGGREGATE의 불변식을 명시하라

- 프로그래밍 언어를 사용해서 프로그램 코드에 ASSERTION을 명시할 수 없다면 자동화된 단위 테스트를 작성해서 ASSERTION의 내용을 표현하라.
- 개발자들이 의도된 ASSERTION을 추측할 수 있게 인도하고, 쉽게 배울 수 있고 모순된 코드를 작성하는 위험을 줄이는 응집도 높은 개념이 포함된 모델을 만들려고 노력하라.
- ASSERTION은 여전히 좋은 설계를 증진시키는 강력한 사고방식이다.

불변식을 비롯해 사전조건과 사후조건을 명확하게 명시하면 객체나 연산을 사용한 결과를 이해할 수 있다.

### CONCEPTUAL CONTOUR (개념적 윤곽)

모델 또는 설계를 구성하는 요소가 모놀리식 구조에 묻혀 있을 경우 각 요소의 기능이 중복된다.

클라이언트는 외부 인터페이스로부터 유용한 정보의 일부만 파악할 수 있을 뿐이다.

서로 다른 개념이 뒤죽박죽으로 섞여 있기 때문에 의미를 파악하기도 어렵다.

반면 클래스와 메서드를 잘게 나누면 클라이언트 객체가 무의미하게 복잡해진다.

이는 클라이언트 객체가 작은 부분들의 협력 방식을 이해하고 있어야 하기 때문이다.

절반의 우라늄 원자는 우라늄이 아니다. 

물론 중요한 것은 입자의 크기가 아니라 입자가 어디에서 움직이고 있느냐다.

도메인을 중요 영역을 나누는 것과 관련한 직관을 감안해서 설게 요소를 응집력 있는 단위로 분해하라.

계속적인 리팩터링을 토대로 변경되는 부분과 변경되지 않는 부분을 나누는 중심 축을 식별하고, 변경을 분리하기 위한 패턴을 명확하게 표현하는 CONCEPTUAL CONTOUR를 찾아라.

우선적으로 확실한 지식 영역을 구성하는 도메인의 일관성 있는 측면과 모델을 조화시켜라.

목표는 UBIQUITOUS LANGUAGE를 사용해 합리적으로 표현하기 위해 논리적으로 결합할 수 있고 관계없는 선택사항으로 인한 혼란과 유지보수의 부담이 없는 단순한 인터페이스 집합을 얻는 것이다.

이것은 일반적으로 리팩터링을 통해 달성할 수 있다.

CONCEPTUAL CONTOUR에 맞춰 설계할 때도 리팩터링과 수정은 필요하다.

---

### STANDALONE CLASS (독립형 클래스)

상호의존성은 모델과 설계를 이해하기 어렵게 만든다.

- 모든 연관관계는 의존성을 의미하므로 클래스를 이해하려면 연관관계를 토대로 어떤 요소가 연결돼있는지 이해해야 한다.
- 의존성이 하나만 있더라도 동시에 두 개의 클래스를 고려해야 하고 그 관계의 본질에 관해 생각해야 한다.
- MODULE과 AGGREGATE 모두 지나치게 얽히고설키는 상호의존성을 방지하는 것이 목적이다.

MODULE 내에서조차 의존성이 증가할수록 설계를 파악하는 데 따르는 어려움이 가파르게 높아진다. 이는 개발자에게 정신적 과부하를 줘서 개발자가 다룰 수 있는 설계의 복잡도를 제한한다. 아울러 명시적인 참조에 비해 암시적인 개념이 훨씬 더 많은 정신적 과부하를 초래한다.

- 암시적인 개념은 명시적인 참조만큼이나 중요하다.
    - 예를 들어 기본 타입에 대한 의존성은 무시할 수 있더라도 그것이 표현하는 바를 무시할 수는 없다.
- 낮은 결합도는 객체 설계의 기본 원리다. 가능한 한 늘 결합도를 낮추고자 노력하라.
- 현재 상황과 무관한 모든 개념을 제거하라.
    - 그러면 클래스가 완전히 독립적으로 바뀌고 단독으로 검토하고 이해할 수 있을 것이다.
    - 그러한 독립적인 클래스는 MODULE을 이해하는 데 따르는 부담을 상당히 덜어준다.

- 같은 모듈에 속하는 클래스 간의 의존성은 모듈 외부에 존재하는 클래스에 대한 의존성에 비해 문제를 덜 일으킨다.
- 가장 복잡다단한 계산을 STANDALONE CLASS로 도출하려고 노력하라.
- 낮은 결합도는 개념적 과부하를 줄이는 기본적인 방법 중 하나다.  STANDALONE CLASS는 극단적으로 결합도를 낮춘 것이다.